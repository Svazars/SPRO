# SPRO Specification


## Introduction

SPRO -- это процессор, в котором семь 16-битных целочисленных регистров и к которому можно подключать до 64 Килобайт оперативной памяти. Он умеет исполнять 16 различных инструкций, которые хранятся в этой оперативной памяти как последовательность 2-байтовых слов. Если инструкция принимает аргументы, то требуемые значения считываются из памяти, расположенной прямо за самой инструкцией. Исполнение инструкции занимает всего 1 такт процессора, а вот обращения к памяти не такие быстрые и занимают целых 3 такта.

Ассемблер, примеры и таблицу команд явно составлял программистоненавистник, `src:dst` "перепутаны" (если вы считаете intel-syntax единственно правильным способом записывать ассемблерный код). Будьте внимательны и осторожны!

## Overview 

Процессор состоит из семи 16-битных регистров (в скобках указано ID, т.е. номер регистра):

 - `IP (0)` - текущая исполняемая инструкция. Каждая инструкция занимает два байта, поэтому всегда исполняется память `[IP, IP+1]`. Важно: `IP` *может* содержать нечетное значение.
 - `SP (1)` - stack pointer. Участвует в инструкциях `Push` и `Pop`, но может использоваться и как регистр общего назначения.
 - `R1 (2)`, `R2 (3)`, `R3 (4)`, `R4 (5)`, `R5 (6)` - регистры общего назначения.

К процессору может быть подсоединена память из `K` двубайтовых слов, т.е. из `N = 2 * K` ячеек. Важно: `N` обязано быть четным, но не обязано быть степенью двойки.

Арифметические операции при переполнении регистра используют wrapping по модулю `2**16 = 65536`. Иными словами, сложение `50_000` и `20_000` приводит к `4464`.

Операции с памятью используют wrapping по модулю `N`. Иными словами, если к процессору подсоединено `150` ячеек памяти, а регистр `SP = 377`, то инструкция `Pop R5` сохранит в регистр `R5` содержимое ячеек под номером `77` и `78`.

Операции перехода используют wrapping по модулю `N`. Иными словами

 - если к процессору подсоединено `444` ячейки памяти, то после исполнения инструкции `Jump 900` регистр `IP` станет равен `12`.
 - если к процессору подсоединено `1024` ячейки памяти, а `IP = 1022`, то после исполнения инструкции `Nop` регистр `IP` станет равен `0`. 

## Instruction format

Каждая инструкция занимает слово (2 байта). Первые 7 бит ("самые левые"; те, которые ближе к адресу 0) занимает instruction id. Оставшиеся 9 бит кодируют тип аргумента (регистр или константа):
```    
номер бита   | 15 | 14 | 13 | 12 | 11| 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
группа       | a  | a  | a  | a  | a | a  | a | b | b | b | c | c | c | d | d | d |
             |--------------IP------------------|---------------IP + 1------------|
``` 

 - группа `a` - instruction id
 - группа `b` - 3rd argument type
 - группа `c` - 2nd argument type
 - группа `d` - 1st argument type

Instruction id -- это номер инструкции в [таблице инструкций](#instruction-set). Если instruction id в таблице не указан, то попытка исполнить такую неопознанную инструкцию эквивалента `Halt`.

Argument type -- если равен `7` (`111` в двоичном представлении), то аргументом выступает константа расположенная в памяти непосредственно за текущей инструкцией. Если меньше `7`, то это номер регистра, из которого надо взять значение аргумента (`000` соответствует `IP`, `001` соответствует `SP` и т.д.).

При записи инструкций в машинных кодах иногда будем использовать бинарную запись, а иногда шестнадцатеричную.

Например `Nop` имеет instruction id равный нулю и не принимает аргументов, значит записывается как 16 нулевых бит или, что то же самое, как 2 нулевых байта:
```
Nop
0b 0000 0000 0000 0000
0x                0000
```

При записи арифметических операций в ассемблере будем использовать нотацию `arg1 arg2 dst`. Например `Add R1, 5, SP` прочитает из регистра `R1` значение, прибавит к нему `5` и присвоит результат в регистр `SP`. В памяти такая инструкция займет 2 слова (сама инструкция + аргумент-константа `5`):
```
Add R1, 5, SP
0b 0001 0000 0011 1010 | 0000 0000 0000 0101
0x                103a |                0005
```

При записи операций с памятью в ассемблере будем использовать нотацию `arg dst`. Например `Store 100, 18` запишет константу `100` в ячейку памяти под номером `18`. В памяти такая инструкция займет 3 слова (сама инструкция + два аргумента-константы):
```
Store 100, 18
0b 0000 1010 0011 1111 | 0000 0000 0110 0100 | 0000 0000 0001 0010
0x                0a3f |                0064 |                0012
```

Полный перечень инструкций и их аргументов дан в [таблице инструкций](#instruction-set).

## Instruction decoding

1. В неиспользуемых битах инструкции может храниться произвольное значение. Например `0x0800`/`0x080F`/`0x08СF` имеют одинаковый ID (= 4), который соответствует инструкции `Halt`. Поэтому все эти слова успешно исполнятся как `Halt`. 
    
2. Некоторые аргументы инструкции не могут быть константами, а только регистрами. Если это нарушается, то эффект эквивалентен выполнению `Halt`: процессор аварийно останавливается.

Пример корректной инструкции:
```
Add r1, 15, R5
0b 0001 0001 1011 1010 | 0000 0000 0000 1111 
0x                11ba |                000f                 
```

Пример некорректной инструкции:
```
Add r1, 15, const
0b 0001 0001 1111 1010 | 0000 0000 0000 1111 | whatever_bin
0x                11fa |                000f | whatever_hex
```

Полный перечень инструкций и ограничений на их аргументы дан в [таблице инструкций](#instruction-set).

## Instruction execution

Пусть инструкция использует `k` аргументов констант и расположена в памяти в слове `[ x, x + 1 ]`. Тогда после ее исполнения, если это не jump-like инструкция, к `IP` прибавится `2` /*сама инструкция*/ и `2 * k` /*аргументы*/. `Jump` устанавливает `IP` в нужное значение и пост-инкремент IP не делается. 

Примеры:
```
Sub IP, 4, IP   ; задает вечный цикл
Mov IP, IP      ; эквивалентна NOP
Sub R3, 4, IP   ; эквивалентна Jump R3
Sub 1448, 6, IP ; эквивалентна Jump 1448
Mov 1444, IP    ; эквивалентна Jump 1448
```

Каждое используемое слово загружается из памяти, что занимает 3 такта процессора. Исполнение загруженной инструкции занимает 1 такт.

Сравните:
```
push 1
push 1
push 1
```
Займет в памяти 6 слов и исполнение кодового фрагмента займет `3 x (загрузка инструкции + загрузка константы + исполнение инструкции)` = 
`3 x (3 + 3 + 1)` = `21` такт.

Против:
```
mov 1, R1
push r1
push r1
push r1
```
Займет в памяти 5 слов и выполнится за `(load_mov + load_const + exec_mov)` + `3 x (load_push + exec_push)` = `(3 + 3 + 1) + 3 x (3 + 1)` = `19` тактов.

Note: Исполнение инструкции `Nop` занимает 4 такта.

## Instruction set

Напоминания:

- инструкции используют wrapping (см. [overview](#overview))
- нерегистровые аргументы инструкций лежат непосредственно после инструкции (см. [instruction format](#instruction-format)) 
- часть битов в инструкции может быть заполнена произвольным мусором, который не влияет на исполнение (см. [instruction decoding](#instruction-decoding))
- часть битов в инструкции обязана содержать допустимый тип аргумента, иначе процессор аварийно завершает работу (см. [instruction decoding](#instruction-decoding))
- "стоимость" инструкции в тактах зависит от количества обращений к памяти (см. [instruction execution](#instruction-execution))

|  ID  |     Name        | Arg 0           |  Arg 1          | Arg 2           |   Semantics                                             |
|:----:|:---------------:|:---------------:|:---------------:|:---------------:|:-------------------------------------------------------:|
| 0    | Nop             |                 |                 |                 |                                                         |
| 1    | Push            | value:GPR/const |                 |                 | SP := SP - 2, value stored into [ SP, SP + 1 ]          |
| 2    | Pop             | dst:GPR         |                 |                 | value from [ SP, SP + 1 ] stored into dst, SP := SP + 2 |
| 3    | Mov             | src:GPR/const   | dst:GPR         |                 |                                                         |
| 4    | Halt            |                 |                 |                 |                                                         |
| 5    | Store           | value:GPR/const | addr:GPR/const  |                 | value is stored into [ addr, addr + 1 ]                 |
| 6    | Load            | addr:GPR/const  | dst:GPR         |                 | value from [ addr, addr + 1 ] stored into dst           |
| 7    | Jump            | addr:GPR/const  |                 |                 |                                                         |
| 8    | Add             | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         |
| 9    | Sub             | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         |
| 10   | Mul             | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         |
| 11   | XOR             | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         |
| 12   | OR              | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         | 
| 13   | AND             | x:GPR/const     | y:GPR/const     | dst:GPR         |                                                         |           
| 14   | JumpZero        | tst:GPR/const   | addr:GPR/const  |                 | if (tst == 0) jump addr else nop                        |
| 15   | JumpEquals      | x:GPR/const     | y:GPR/const     | addr:GPR/const  | if (x == y) jump addr else nop                          |

## Examples

### Position independent loop

```
; ---- init -----
Add IP, 16, R1   ; R1 := IP + 16 == LOOP_START
Add IP, 30, R2   ; R2 := IP + 30 == AFTER_LOOP
Mov 0 , R4       ; R4 := 0
Mov 15, R5       ; R5 := 15
; ---- loop ----
Mov R5, R3       ; R3 := R5   <----------------LOOP_START-----------------|
JumpZero R5, R2  ; if (R5 == 0) goto AFTER_LOOP                           |
Mul R3, R3, R3   : R3 := R3 * R3                                          |
Add R3, R4, R4   ; R4 += R3                                               |
Sub 1, R5, R5    ; R5--                                                   |
Jump R1          ; goto R1 --- goto LOOP_START ---------------------------|
; ---- after loop ---- 
; R4 = 15*15 + 14*14 + ... + 1*1
```

### Self-modifying code

```
; we expect that this program is loaded at address 0
Mov       0, R5 ; <----------------------------------------|
Store  2048, 0  ; 2048 is 0x8000 which is Halt             |
JumpZero R5, 0  ; -----------------------------------------|
; Yes, it is NOT an infinite loop, it explodes
```
